using System;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using TMPro;
using UnityEngine;
using UnityEngine.UI;
using UnityEngine.Events;
using UnityEngine.Networking;
using UnityEditor;
using System.IO;
using System.Threading;
public class AIImgGenerator : MonoBehaviour
{
    /// <summary>
    /// Api Key for Open AI API can be generated <see href="https://platform.openai.com/account/api-keys">HERE</see>
    /// </summary>
    public string apiKey;
    /// <summary>
    /// Invoked when Image has been generated by GetImageFromPrompt call
    /// (Sets texture to null in case of error)
    /// </summary>
    public Action<Texture2D> OnImageGenerated;
    private const string APILink = "https://api.openai.com/v1/images/generations";
    private const string APILinkVariation = "https://api.openai.com/v1/images/variations";




    [Header("UI References")]
    public Image uiImage;
    public Button generateButton;
    public Button variationButton;
    public GameObject loading;
    public TMP_InputField text;
    public int imageSize;
    private Texture2D _lastTex;

    private void OnEnable()
    {
        generateButton.onClick.AddListener(() =>
        {
            GetImageFromPrompt(new InputData(text.text, 1, imageSize));
            generateButton.interactable = false;
            loading.SetActive(true);
        });

        variationButton.onClick.AddListener(() =>
        {
            GetImageFromPrompt2(new ImgVariationData(texttoPng(), 1 , imageSize));
            variationButton.interactable = false;
        });
        OnImageGenerated += SetUIImage;
    }

    private void SetUIImage(Texture2D tex)
    {
        generateButton.interactable = true;
        loading.SetActive(false);
        if (!tex)
        {
            Debug.LogError("Something Went Wrong try again");
        }
        if (_lastTex) Destroy(_lastTex);
        _lastTex = tex;
        uiImage.sprite = Sprite.Create(tex, new Rect(0.0f, 0.0f, tex.width, tex.height), new Vector2(0.5f, 0.5f), 100.0f);
       // variationButton.gameObject.SetActive(true);
    }

    /// <summary>
    /// Get image using input data
    /// </summary>
    /// <param name="promptData"></param>
    public void GetImageFromPrompt(InputData promptData)
    {
        if (string.IsNullOrEmpty(apiKey))
        {
            Debug.LogError("Api Key is needed to access Open AI Api See Link :" +
                           "https://platform.openai.com/account/api-keys");
            return;
        }
        if (string.IsNullOrEmpty(promptData.prompt))
        {
            Debug.LogError("Input Prompt can not be empty");
            return;
        }
        StartCoroutine(SendRequest(promptData));
    }
    public void GetImageFromPrompt2(ImgVariationData promptData)
    {
        if (string.IsNullOrEmpty(apiKey))
        {
            Debug.LogError("Api Key is needed to access Open AI Api See Link :" +
                           "https://platform.openai.com/account/api-keys");
            return;
        }
        StartCoroutine(SendRequest2(promptData));
    }

    #region Main

    /* Example Request 
       curl https://api.openai.com/v1/images/generations \
        -H "Content-Type: application/json" \
        -H "Authorization: Bearer $OPENAI_API_KEY" \
        -d '{
         "prompt": "A cute baby sea otter",
         "n": 2,
         "size": "1024x1024"
       }'

      */
    Texture2D tex;
    private IEnumerator SendRequest(InputData promptData)
    {
        // convert our  custom class into json format as it is required. See https://platform.openai.com/docs/api-reference/images/create //
        // the format is prompt, number of images, size e.g 512x512 // 
        // response_format: The format in which the generated images are returned. Must be one of url or b64_json 

        string json = JsonUtility.ToJson(promptData);

        var request = new UnityWebRequest();
        request = new UnityWebRequest(APILink);
        request.uploadHandler = new UploadHandlerRaw(Encoding.UTF8.GetBytes(json));
        request.uploadHandler.contentType = "application/json";
        request.downloadHandler = new DownloadHandlerBuffer();
        request.method = UnityWebRequest.kHttpVerbPOST;
        request.SetRequestHeader("Authorization", "Bearer " + apiKey);
        yield return request.SendWebRequest();

        if (request.result != UnityWebRequest.Result.Success)
        {
            OnImageGenerated?.Invoke(null);
            Debug.Log("Error " + request.error);
        }
        else
        {
            Result res = JsonUtility.FromJson<Result>(request.downloadHandler.text);
            Debug.Log(res.data[0].url);
            var textureRequest = UnityWebRequestTexture.GetTexture(res.data[0].url);
            textureRequest.SendWebRequest();
            yield return new WaitUntil(() => textureRequest.isDone);

            if (textureRequest.result == UnityWebRequest.Result.Success)
            {
                tex = DownloadHandlerTexture.GetContent(textureRequest);
                OnImageGenerated?.Invoke(tex);
                //saveImg();
            }
            else
            {
                OnImageGenerated?.Invoke(null);
                Debug.Log(textureRequest.error);
            }

        }
    }

    private IEnumerator SendRequest2(ImgVariationData promptData)
    {

        //  string json = JsonUtility.ToJson(promptData);
        //  Debug.Log(json);
        //  //var request = new UnityWebRequest();
        //  //request = new UnityWebRequest(APILinkVariation);
        //  var request = new UnityWebRequest(APILinkVariation, UnityWebRequest.kHttpVerbPOST);
        //  request.uploadHandler = new UploadHandlerRaw(Encoding.UTF8.GetBytes(json));
        ////  request.uploadHandler.contentType = "application/octet-stream";
        //  request.SetRequestHeader("Authorization", "Bearer " + apiKey);
        //  request.downloadHandler = new DownloadHandlerBuffer();
        //  yield return request.SendWebRequest();

        //  if (request.result != UnityWebRequest.Result.Success)
        //  {
        //      Debug.Log("came");
        //      //OnImageGenerated?.Invoke(null);
        //      Debug.Log(request.error);
        //  }
        //  else
        //  {
        //      Result res = JsonUtility.FromJson<Result>(request.downloadHandler.text);
        //      var textureRequest = UnityWebRequestTexture.GetTexture(res.data[0].url);
        //      textureRequest.SendWebRequest();
        //      yield return new WaitUntil(() => textureRequest.isDone);

        //      if (textureRequest.result == UnityWebRequest.Result.Success)
        //      {
        //          tex = DownloadHandlerTexture.GetContent(textureRequest);
        //          OnImageGenerated?.Invoke(tex);

        //      }
        //      else
        //      {
        //          OnImageGenerated?.Invoke(null);
        //          Debug.Log(textureRequest.error);
        //      }

        //  }

        var imageFilePath = promptData.image;
        byte[] imageData = File.ReadAllBytes(imageFilePath);

        // Create a new UnityWebRequest object for the API endpoint

        // Add the authentication token to the request headers
      
        List<IMultipartFormSection> formData = new List<IMultipartFormSection>();
        // Add the image file and other form data to the request body
        MultipartFormDataSection imageSection = new MultipartFormDataSection("image", imageData, "image/png");
        MultipartFormDataSection numVariationsSection = new MultipartFormDataSection("n", 1.ToString());
        MultipartFormDataSection outputSizeSection = new MultipartFormDataSection("size", promptData.size);


        formData.Add(imageSection);
        formData.Add(numVariationsSection);
        formData.Add(outputSizeSection);

        UnityWebRequest request = UnityWebRequest.Post("https://api.openai.com/v1/images/variations", formData);
        request.SetRequestHeader("Authorization", "Bearer " + apiKey);
        // Send the request and wait for a response
        yield return request.SendWebRequest();

        if (request.result == UnityWebRequest.Result.Success)
        {
            // Process the response data here
            Debug.Log(request.downloadHandler.text);
        }
        else
        {
            Debug.LogError("Error sending image variation request: " + request.error);
        }

    }




    void saveImg()
    {
    
        byte[] bytes = tex.EncodeToPNG();
        File.WriteAllBytes(Application.dataPath + "/Resources/img.png", bytes);
        AssetDatabase.Refresh();
    }

    public string texttoPng()
    {
        //byte[] bytes = tex.EncodeToPNG();
        //string enc = Convert.ToBase64String(bytes);
        //return enc;
          string path = Application.dataPath + "/Resources/img.png";
          //string path = "Assets/Resources/img.png";
        //string path = "@img.png";

        Debug.Log(path);
        return path;
        //if (File.Exists(Application.dataPath + "/img.png"))
        //{
        //    return Application.dataPath + "/img.png";
        //}
        //else
        //    return "";
    }
    #endregion

    #region Models

    [Serializable]
    public class InputData
    {

        public string prompt;
        public int n;
        public string size;
        /// <summary>
        /// Input data to generate Image from
        /// </summary>
        /// <param name="prompt">Input prompt as text</param>
        /// <param name="numberOfImages">Number of images to generate from prompt</param>
        /// <param name="size">Input to generate (size x size) image</param>
        public InputData(string prompt, int numberOfImages, int size)
        {
            this.prompt = prompt;
            n = numberOfImages;
            this.size = size + "x" + size;
        }
    }  
    [Serializable]
    public class ImgVariationData
    {

        public string image;
        public int n;
        public string size;
        /// <summary>
        /// Input data to generate Image from
        /// </summary>
        /// <param name="prompt">Input prompt as text</param>
        /// <param name="numberOfImages">Number of images to generate from prompt</param>
        /// <param name="size">Input to generate (size x size) image</param>
        public ImgVariationData(string prompt, int numberOfImages, int size)
        {
            this.image = prompt;
            n = numberOfImages;
            this.size = size + "x" + size;
        }
    }

    [Serializable]
    public class ReceivedData
    {
        public string url;
    }

    [Serializable]
    public class Result
    {
        public int created;
        public List<ReceivedData> data;
    }

    public class ImageEvent : UnityEvent<List<Sprite>> { }

    #endregion
}
